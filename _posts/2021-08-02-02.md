---
layout: post
categories: Java
title: Java8 的 G1 垃圾回收器相对于之前的 CMS 有什么特别的呢？
tagline: by 子悠
tags: 
  - 子悠
---

### CMS

CMS 垃圾回收器，全称**Concurrent Mark Sweep** 并发标记-清除，从名字上面我们也可以看出这个垃圾回收器是基于标记清除算法实现的。首先"并发"表示 GC 线程可以和用户线程并发执行，同时既然是标记-清除算法，说明这个垃圾回收器会产生很多碎片，这是标记-清除算法的缺点。同时 CMS 是作用于老年代的，老年代的垃圾回收频率相对年轻代会低一点。

<!--more-->

CMS 的垃圾回收有四个过程

1. 初始标记：
2. 并发标记：
3. 重新标记：
4. 并发清除：

初始标记的时候是一个 STW （stop the world）的过程，所有的用户线程都会停止，这个时候只是标记一下 GC Roots 能直接达到的对象，由于只是标记一层所以整个速度相对会比较快。

并发标记是一个 GC Roots 扫描的过程，会扫描整个链路标记可以回收的对象；由于整个的链路会比较长，所以相对会耗时久一点，不过由于这个过程是并发的，所以对用户线程运行是没有影响的。

重新标记顾名思义是一个再次标记的过程，同时也是会 STW，之所以会有这个重新标记的过程，是因为在上一步并发标记的过程中，用户线程依旧在运行，所以对象的引用关系会发生变化同时在运行的时候也会产生新的垃圾。这里只会标记在上一步有发生变化的对象，虽然会 STW 不过速度也较快。

并发清除是最后一个阶段，这个阶段由于需要清除之前扫描的所有垃圾对象，所以会相对比较耗时，不过这个阶段是可以并发进行的所以对用户线程的运行不会有影响。

经过上面的四个过程就完成了一次完整的 GC，前面我们提到整个 CMS 垃圾回收器是基于标记-清除算法的，先通过三个过程标记出需要清理的对象，然后再进行清理。整个过程中初始标记和重新标记会触发 STW，其他两个阶段是并发进行的。标记-清除算法会产生内存碎片，所以不适合需要频繁回收的年轻代，所以只适合老年代。产生碎片是 CMS 的缺点，并发是 CMS 的优点，毕竟任何一个收集器都会有优缺点。

### G1

前面我们聊完了 CMS，接下来我们聊一下 G1，G1 全称garbage First，再讲 G1 垃圾回收器的细节之前，我们首先要知道的是 G1 对整个堆的空间做了重新的定义。G1 中的老年代也年轻代已经不再是物理隔离的了，而是逻辑隔离。在 G1 中整个堆空间被分成了一个个相同大小的 Region 块，多个 Region 块在逻辑上组成了年轻代和老年代。

这样做的目的是因为在进行垃圾回收的时候不需要进行整个堆空间的扫描，同时可以根据指定停顿时间来进行垃圾回收。



