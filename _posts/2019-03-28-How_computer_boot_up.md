---
layout:post
category:operating system
title: 计算机启动过程
tagline: by AdamWong
tags:
   - Operating system
   - 面试
published:true
---



# 介绍

操作系统老师说，平时面试学生或者毕业答辩的时候他都会问这个问题，可见这个问题对于计算机专业的学生来说是如此重要。那么，从打开计算机电源到计算机的屏幕显示，中间经历了哪些过程呢？

<!--more-->

启动的英文是`boot`，来自于一个谚语

```
pull oneself up by one's bootstraps

```
通过拉自己的鞋带把自己拽起

这个很明显是矛盾的。工程师早期用这句谚语用来比喻早期的计算机开机，
因为计算机启动需要运行程序，而运行程序又需要计算机启动。这个是一个很矛盾的过程。直到后来开机程序被刷入`ROM`芯片后，这个开机的`boot`

大概过程是这样的:
1. Turn on

2. CPU jump to physical address of BIOS(In Intel it is 0xFFFF0)

3. BIOS runs POST(Power-On Self Test)

4. Find bootable devices

5. Loads boot sector from MBR

6. BIOS yields control to OS BootLoader

   

# 1. BIOS

BIOS介绍:
```
BIOS（Basic Input/Output System）是基本输入输出系统的简称。BIOS 能为电脑提供最低级、最直接的硬件控制与支持，是联系最底层的硬件系统和软件系统的桥梁。为了在关机后使 BIOS 不会丢失，早期的 BIOS 存储在 ROM 中，并且其大小不会超过 64KB；而目前的 BIOS 大多有 1MB 到 2MB，所以会被存储在 闪存（Flash Memory）中。
```

 

BIOS 设置程序是被固化到电脑主板上地 ROM 芯片中的一组程序，其主要功能是为电脑提供最底层的、最直接的硬件设置和控制。 BIOS 通常与
**硬件系统**集成在一起（在计算机主板的 ROM 或EEPROM 中），所以也被称为 **固件**



![BIOS界面](https://www.lifewire.com/thmb/AeRVf2oW46AaeaFSwSGDxFHGF28=/768x0/filters:no_upscale():max_bytes(150000):strip_icc()/phoenix-bios-setup-utility-5a0b5e1cda271500370cf924.PNG)

**如何运行**

BIOS存放在一个断电后不会丢失内容的ROM中，这保证了“拽着鞋带拉起自己”的这种情况不会发生。因为系统一上电或重置，处理器要执行第一条指令的地址会被定位到BIOS存储器，初始化开始运行。在X86系统中，CPU加电后跳转至BIOS的固定物理地址0xFFFF0。
打开计算机电源，计算机会首先加载BIOS，包含

```
CPU相关信息
设备启动顺序信息
硬盘信息
内存信息
时钟信息
PhP特性
...
```



**硬件自检(Power-On Self Test,POST)**
如果硬件出现问题，主板会发出不同含义的蜂鸣 ，启动中止。如果没有问题，屏幕就会显示出CPU 、内存、硬盘等信息。BIOS在执行完硬件自检和初始化后，会将自己复制到从 0xA0000 开始的物理内存中并继续执行。

```
BIOS 代码包含诊断功能，以保证某些重要硬件组件，像是
键盘、磁盘设备、输出输入端口等等，可以正常运作且正
确地初始化。
```



**BIOS产生的问题**

1. 开发效率低：大部分BIOS代码使用汇编开发，开发效率不言而喻。汇编开发的另一个缺点是使得代码与设备的耦合程度太高，代码受硬件变化的影响大。
2. 性能差：BIOS基本输入/输出服务需要通过中断来完成，开销大，并且BIOS没有提供异步工作模式，大量的时间消耗在等待上。
3. 功能扩展性差，升级缓慢：BIOS代码采用静态链接，增加硬件功能时，必须将16位代码放置在0x0C0000～0x0DFFFF区间，初始化时将其设置为约定的中断处理程序。而且BIOS没有提供动态加载设备驱动的方案。
4. 安全性：BIOS运行过程中对可执行代码没有安全方面的考虑。
5. 不支持从硬盘２TB以上的地址引导：受限于BIOS硬盘的寻址方式，BIOS硬盘采用32位地址，因而引导扇区的最大逻辑块地址是232(换算成字节地址，即232×512=2TB)


由于这些问题的存在，`UEFI`横空出世

![](https://upload.wikimedia.org/wikipedia/commons/8/8d/Efi_flowchart_extended.jpg?1553175603751)

UEFI中文名为**统一可扩展固件界面**(英语：Unified Extensible Firmware Interface，缩写**UEFI**)是一种个人电脑系统规格，用来定义操作系统与系统硬件之间的软件界面，作为BIOS的替代方案。可扩展固件接口负责加电自检（POST），联系操作系统以及提供连接作业系统与硬体的介面。


**UEFI与BIOS的几个区别**
1. EFI使用模块化、C语言风格的参数堆栈传递方式以及动态链接形式构建的系统，相对于BIOS而言跟容易实现，容错和纠错特性更强，减少系统研发的时间。

2. 运行于32位或64位模式，面对未来增强的处理器模式下，能突破BIOS 16位代码的寻址能力，达到处理器最大寻址。

3. UEFI有良好的鼠标操控图形化界面，在开机速度也比BIOS快不少

  

  

**BIOS**过程
![](/assets/images/img-csboot/BIOS-process.png)

**UEFI**过程
![](/assets/images/img-csboot/UEFI-process.png)

相对来说UEFI比BIOS少了一个硬件检测

即使如此，本章启动过程还是着重于分析利用BIOS启动的过程。



# 2.读取MBR

MBR-全称是Master Boot Record(主引导记录或主开机记录)，是一个512byte的扇区，位于磁盘的固定位置。之所以叫“主引导记录”，是因为其存在于驱动器开始部分的一个特殊扇区，个扇区包含已安装的操作系统启动记载器和驱动器的逻辑分区信息。BIOS完成POST和初始化之后，会根据CMOS中设定的顺序选择引导的设备，这个设备可以是U盘可以是硬盘。若设置为硬盘，则BIOS就会读取MBR。MBR里面包含了一段引导程序，一个分区表和Magic Number。



**MBR的结构**

![](http://www.maixj.net/pics/uploads/2017/06/MBR.jpg)

| 位置        | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| 1-445字节   | 调用操作系统的机器码(Call OS)                                |
| 447-510字节 | 分区表(Partition table)                                      |
| 511-512字节 | 主引导记录签名(只有两个，0x55和0xAA，为Magic Number)，如果不是这两个幻数，就认为这是一个没有被分区的硬盘。 |

分区表的长度只有64个字节，里面分为四项，每项为16个字节。所以一个硬盘只可以分四个一级分区，又叫做“主分区”。每个主分区的16个字节，结构如下

| 位置(字节) | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| 1          | 如果第一个为0x80，表示该主分区是激活分区(active)，控制权将转交给此分区。几个分区中只能有一个是激活分区，其他都是非激活分区(inactive)。 |
| 2-4        | 主分区的第一个扇区物理位置(柱面、磁头、扇区号等)             |
| 5          | 主分区的类型  分区类型符 |
| 6-8        | 主分区最后一个扇区的物理位置                                 |
| 9-12       | 主分区第一个扇区的逻辑位置                                   |
| 13-16      | 主分区的扇区总数，决定了主分区的长度                         |



其中第5字节分区类型符，有如下特定符

00H H —— 表示该分区未用 （ 即没有指定 ） ；

06H H —— FAT 16 基本分区；

0 0 BH —— FAT 32 基本分区；

05H H —— 扩展分区；

07H H —— NTFS 分区；

0 0 FH —— （ LBA 模式 ） 扩展分区 (83H H 为 Linux) 

 分出主分区后，其余的部分可以分成扩展分区，一般是剩下的部分全部分成扩展分区，也可以不全分，剩下的部分就浪费了。扩展分区不能直接使用，必须分成若干逻辑分区。所有的逻辑分区都是扩展分区的一 部分 。

```
硬盘的容量 ＝ 主分区的容量 ＋ 扩展分区的容量

扩展分区的容量 ＝ 各个逻辑分区的容量之和
```



# 3.启动Boot Loader

![](https://resources.infosecinstitute.com/wp-content/uploads/040213_2007_LinuxBootin1.png)

​                                                                      **Linux的Boot的过程 **



**Boot Loader**

又叫做 操作系统内核加载器(OS kernel loader)，一个在`kernel`运行前运行的一段小程序，通过这段程序可以初始化硬件设备，建立内存空间的映射，将系统软硬件环境带到一个合适的状态，便于未来调用操作系统内核。

Linux下引导加载程序常见两种[LILO](https://www.wikiwand.com/zh-hk/LILO)和[GNU GRUB](https://www.wikiwand.com/zh/GNU_GRUB)

| LILO                        | GRUB                                         |
| --------------------------- | -------------------------------------------- |
| 无交互命令界面              | 有交互命令界面                               |
| 不支持网络引导              | 支持                                         |
| 错误配置MBR会让系统无法引导 | 如果配置文件错误，则默认跳转到GRUB命令行界面 |



GRUB 磁盘引导的过程如下

```
- stage1: grub 读取磁盘第一个 512 字节(硬盘的0道0 面1扇区，被称为 MBR (主引导记录)， 也称为bootsect )。 MBR 由一部分 bootloader 的引导代
码、分区表和魔数三部分组成。（ 启动的第二步 ）
- Stage1.5: 识别各种不同的文件系统格式。这使得 grub 识别到文件系统。
- stage2: 加载系统引导菜单 (/boot/grub/ menu.lst或 grub.lst) ) ，加载内核映像 (kernel image) 和 RAM磁盘 initrd （可选）。
```



**运行主引导程序的具体过程**

BIOS将硬盘主引导记录读入7C00处，并将控制权交给主引导程序:

1. 检查0x7dfe地址处是否等于0xaa55。不是则去其他介质；如果没有启动的介质，显示“No ROME BASIC”并死机。
2. 成功找到介质，跳转到0X7C00执行MBR的程序
3. 将自己复制到0x0600处且继续执行
4. 主分区表中搜索标志为激活的分区，如果发现没有激活分区或者不止一个激活分区则停止。
5. 将激活分区的第一个扇区读入内存地址0x7c00
6. 再次检查位于地址0x7dfe的内容是否等于0xaa55，若不等则停止并尝试软盘启动
7. 跳转到0x7c00继续执行特定系统的启动程序



**补充：MBR和引导扇区的关系**

![](/assets/images/img-csboot/MBR.png)



- MBR存放的位置是整个硬盘的第一个扇区
- Boot Sector是硬盘上每一个分区的第一个扇区



# 4. 加载kernel

主要有两个步骤:

- 根据 grub 设定的内核映像所在路径 ,系统读取内存映像 ,并进行解压缩操
  作 。

- 系统将解压后的内核放置在内存之中， 初始化函数并初始化各种设备 ， 完
  成 Linux 核心环境的建立 。



以Linux系统为例，先载入/boot目录下面的kernel。

内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。

然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入username和password。

至此，全部启动过程完成。

![](/assets/images/img-csboot/All_Process.png)
