---
layout: post
title:  再谈 HTTP，你还要继续更新不？
tagline: by 懿
categories: java
tag: 
    - java
---

之前的第一篇文章我介绍了关于 HTTP 的一些简单的知识，比如说它的状态码，请求方式，以及 HTTP 的报文，这篇文章我将给大家带来关于 HTTP 版本的那些问题，比如说1.0和1.1和2.0.
<!--more-->

## HTTP 的发展历史

之前的文章直接从内容开始，那这篇文章我就先以历史来开始，HTTP (超文本传输协议)，在创建之初就是为了将超文本标记语言（HTML）文档从 web 服务端传送给浏览器的客户端。随着我们网页内容变得复杂，不单单有文字、图片，还有 css ，js 等等渲染，ajax 的出现、移动互联网的高速发展，随着时代的变迁，HTTP 也一直升级优化，丰富自己的功能特性。

**HTTP 0.9**

0.9协议是适用于各种数据信息的简洁快速协议，但是远不能满足日益发展的各种应用的需要。0.9协议就是一个交换信息的无序协议，仅仅限于文字。由于无法进行内容的协商，在双发的握手和协议中，并有规定双发的内容是什么，也就是图片是无法显示和处理的。

这个版本就说图片都不能处理，那不用想，这个版本很快就被抛弃了。

**HTTP 1.0**

到了1.0协议阶段，也就是在1982年，TimBerners-Lee 提出了 HTTP 1.0。在此后的不断丰富和发展中，HTTP 1.0 成为最重要的面向事务的应用层协议。该协议对每一次请求/响应建立并拆除一次连接。其特点是简单、易于管理，所以它符合了大家的需要，得到了广泛的应用。

**HTTP 1.1**

在1.0协议中，双方规定了连接方式和连接类型，这已经极大扩展了 HTTP 的领域，但对于互联网最重要的速度和效率，并没有太多的考虑。毕竟，作为协议的制定者，当时也没有想到 HTTP 协议会有那么快的普及速度。 关于 HTTP 1.1 协议的具体内容可以参考 RFC 2616。

**HTTP 2.0**

HTTP 2.0 的前世是 HTTP 1.0 和 HTTP 1.1。虽然之前仅仅只有两个版本，但这两个版本所包含的协议规范之庞大，足以让任何一个有经验的工程师为之头疼。网络协议新版本并不会马上取代旧版本。实际上，1.0和1.1在之后很长的一段时间内一直并存，这是由于网络基础设施更新缓慢所决定的。

## HTTP 1.0 和 HTTP 1.1 的区别

**1.长连接：减少了建立和关闭连接的消耗和延迟。**

HTTP 1.0 : 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。

HTTP 1.1 : 则支持持久连接 Persistent Connection, 并且默认使用 persistent  connection。 在同一个 TCP 的连接中可以传送多个 HTTP 请求和响应。 多个请求和响应可以重叠，多个请求和响应可以同时进行。更加多的请求头和响应头(比如 HTTP 1.0 没有 host 的字段)。

**2.缓存处理**

HTTP 1.0 ：中主要使用 header 里的 If-Modified-Since , Expires 来做为缓存判断的标准。

HTTP 1.1 ：则引入了例如 ETag，If-None-Match 等更多可供选择的缓存头来控制缓存策略。

**3.Host 头处理：支持 Host 头域，不在以 IP 为请求方标志**

HTTP 1.0 ：中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名。但随着虚拟主机技术的发展，一台服务器上可以存在多个虚拟主机，共享一个 IP 地址。

HTTP 1.1 ：的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request ）。

**4.错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态**

HTTP 1.1 中新增了24个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

## HTTP 1.1 和 HTTP 2.0 的区别

**1.新的传输格式**

HTTP 1.1 ：使用基于文本格式

HTTP 2.0 ：使用二进制格式

**2.多路复用**

为什么会出现多路复用呢？那么多路复用到底又是什么呢？看懿来给你解析一波。

为什么在2.0的时候会出现多路复用，那不用说，肯定1.1出问题了，HTTP 1.1 有什么问题呢？重点：**效率**。

HTTP 1.1 虽然解决了多次连接的问题，但是它存在一个致命的缺陷，效率低下。

1. 串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么 a 文件用时为3秒，b 文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）

2. 连接数过多。我们假设 `Apache` 设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。

就这两个问题，1.1的效率强行的被拉下来了，这时候2.0的多路复用就为解决这个问题而出现了。

说多路复用，不的不说一下1.1的持久连接，而这个持久连接，就是我们接下来所说的 Keep-Alive 。

**Keep-Alive**：

Keep-Alive 是使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。我们知道 HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（ HTTP 协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接）时，Keep-Alive 功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。

![](http://www.justdojava.com/assets/images/2019/java/image_yi/10_13/1.jpg)

HTTP 1.0中默认是关闭的，需要在 HTTP 头加入" Connection: Keep-Alive"，才能启用 Keep-Alive ；HTTP 1.1中默认启用 Keep-Alive ，如果加入"Connection: close "，才关闭。目前大部分浏览器都是用 HTTP 1.1协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。

HTTP 1.1 和 HTTP 2.0 的区别来了，多路复用，什么是多路复用呢？

举个例最简单的例子：
```
从A地到B地
坐公交2块。打车要20块
为什么坐公交便宜呢
这里所讲的就是“多路复用”的原理。

```

我们再来看一幅图，这图是网上嫖来的哈，百度上好多，

![](http://www.justdojava.com/assets/images/2019/java/image_yi/10_13/2.jpg)

这也是 HTTP 2.0的复用连接，虽然依然遵循请求-响应模式，但客户端发送多个请求和服务端给出多个响应的顺序不受限制，这样既避免了"队头堵塞"，又能更快获取响应。在复用同一个 TCP 连接时，服务器同时(或先后)收到了 A、B 两个请求，先回应A请求，但由于处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。HTTP 2.0长连接可以理解成全双工的协议。

因为HTTP 2.0引入二进制`数据帧`和`流`的概念，其中帧对数据进行顺序标识，也就是说，我们传递一个字符串的时候，比如说，我要传递一个，“别说了，我爱你”，HTTP 1.1是按照一个顺序传输，那么 HTTP 2.0是怎么传输的，看图：

![](http://www.justdojava.com/assets/images/2019/java/image_yi/10_13/3.jpg)

浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。

这也就是解决了问题1，那么怎么解决问题2呢？HTTP 2.0 对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样 Apache 的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍！

这就是多路复用，是不是很好理解。

**3.头部header压缩**

HTTP 1.x的 header 带有大量信息，而且每次都要重复发送，HTTP 2.0使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。

以上就是我想给大家介绍的关于HTTP的版本更迭的那些问题，下篇文章将会给大家介绍HTTP 是如何使用 TCP 连接的？TCP 连接的时延、瓶颈以及存在的障碍；敬请期待呦

我是懿，一个正在被打击却努力前进的码农。


